"""A model for working with CDF data.
"""

from __future__ import annotations
import json, warnings, os
from collections import OrderedDict
from typing import Any, List, Dict, Optional

from thefuzz import fuzz
from pydantic import BaseModel, Json
import numpy as np
import pandas as pd

from hectre.consts import (
    CDF_COMPARE_COLS_IGNORE,
    CDF_COMPOUND_KEY_COLS,
    HEADER_ORDER,
    LITERATURE_DATA_HEADERS,
    NO_DATA
)

# Create fields dynamically for LiteratureData and Result models based on definitions.json
# Create method of CDF to create dataframe from LiteratureData and Results

class CDFData(BaseModel, extra='allow'):
    def __init__(self, **kwargs):
        super().__init__()
        for key, val in kwargs.items():
            setattr(self, key, val)


    @classmethod
    def from_dict(cls, values: Dict) -> CDFData:
        return cls(**values)
    

    @classmethod
    def from_dicts(cls, *dicts: Dict[str, Any]) -> CDFData:
        values = OrderedDict()
        for header in HEADER_ORDER:
            for dictionary in dicts:
                if header in dictionary:
                    values[header] = dictionary[header] if NO_DATA not in str(dictionary[header]) else ""
                    break
            if header not in values:
                values[header] = ""
        return cls(**values)


    @classmethod
    def from_json(cls, *json_strs: Json[Dict]) -> CDFData:
        values = {}
        for json_str in json_strs:
            deserialized = json.loads(json_str)
            values.update(deserialized)
        return cls.from_dict(values)
    

class CDF(BaseModel):
    literature_data: Optional[CDFData] = None
    clinical_data: List[CDFData] = []


    def set_literature_data(self, values: CDFData) -> None:
        self.literature_data = values

    
    def add_clinical_data(self, values: CDFData) -> None:
        self.clinical_data.append(values)

    
    def to_df(self) -> pd.DataFrame:
        rows = []
        for result in self.clinical_data:
            row = result.model_dump()
            for key, val in self.literature_data.model_dump().items():
                if str(val) and NO_DATA not in str(val):
                    row[key] = val
            rows.append(row)
        df = pd.DataFrame(rows)
        return df
    

    def save_to_string(self) -> str:
        # Return the full CSV string
        return self.to_df().to_csv(index=False)
    

    def save_to_file(self, name, path=os.path.join(os.path.dirname(__file__), "../../output")) -> None:
        # Save the CDF contents to file
        if not os.path.exists(path):
            os.makedirs(path)
        self.to_df().to_csv(index=False, path_or_buf=os.path.join(path, f"{name}.csv"))


    def compare(self, test_cdf: pd.DataFrame, control_cdf: pd.DataFrame):
        """
        description:
        Compares a test cdf to a control cdf to determine how accurate the test cdf is.

        returns:
        A dictionary with results that describe the accuracy of the test CDF.

        params:
        test_cdf: The cdf we're testing for accuracy (ususally generated by HECTRE)
        control_cdf: The cdf we're comparing to the test cdf to determine accuracy. Considered to be 100% accurate.
        """
        # Suppress performance warning, our volume is low so this will not affect us.
        warnings.simplefilter(action='ignore', category=pd.errors.PerformanceWarning)
        # Cast test and control DataFrame column types to str so we can compare values directly.
        test_cdf = test_cdf.astype(str).replace('nan', '')
        control_cdf = control_cdf.astype(str).replace('nan', '')
        # Drop ingnored columns if they exist.
        for col in CDF_COMPARE_COLS_IGNORE:
            if col in test_cdf.columns:
                test_cdf = test_cdf.drop(columns=[col])
            if col in control_cdf.columns:
                control_cdf = control_cdf.astype(str).replace('nan', '').drop(columns=[col])
        # Make sure they have the same columns.
        cols_eq = set(test_cdf.columns) == set(control_cdf.columns)
        if not cols_eq:
            cols = f'Test CDF Columns:\n{test_cdf.columns}\n\nControl CDF Columns:\n{control_cdf.columns}\n\n'
            raise RuntimeError(f'The columns in the test and control CDFs are not the same\n\n{cols}')
        test_lit_data = test_cdf.loc[0,LITERATURE_DATA_HEADERS]
        test_clin_data = test_cdf.drop(columns=LITERATURE_DATA_HEADERS)
        # DF of just compound keys.
        test_clin_data_index_vals = test_clin_data[CDF_COMPOUND_KEY_COLS]
        # Transform compound keys to lowercase, remove whitespace, replace hyphens.
        test_clin_data_index_vals = test_clin_data_index_vals.map(lambda x: x.lower()).map(lambda x: x.replace('-', '')).map(lambda x: x.replace(' ', ''))
        # We need a list of compound key columns as lists.
        test_clin_data.set_index([np.array(l) for l in test_clin_data_index_vals.T.values],inplace=True)
        # Confrol CDF (considered 100% accurate)
        control_lit_data = control_cdf.loc[0,LITERATURE_DATA_HEADERS]
        control_clin_data = control_cdf.drop(columns=LITERATURE_DATA_HEADERS)
        # DF of just compound keys.
        control_clin_data_index_vals = control_clin_data[CDF_COMPOUND_KEY_COLS]
        # Transform compound keys to lowercase, remove whitespace, replace hyphens.
        control_clin_data_index_vals = control_clin_data_index_vals.map(lambda x: x.lower()).map(lambda x: x.replace('-', '')).map(lambda x: x.replace(' ', ''))
        # We need a list of compound key columns as lists.
        control_clin_data.set_index([np.array(l) for l in control_clin_data_index_vals.T.values],inplace=True)
        clin_results = self.compare_clinical_data(test_clin_data, control_clin_data)
        lit_results = self.compare_literature_data(test_lit_data, control_lit_data)
        results = {
            "test_clin_data": test_clin_data,
            "test_lit_data": test_lit_data,
            "control_clin_data": control_clin_data,
            "control_lit_data": control_lit_data,
            "comp_rows_clin": clin_results['comp_rows'],
            "comp_values_clin": clin_results['comp_values'],
            "comp_values_lit": lit_results['comp_values'],
            "num_matched_rows": clin_results['num_matched_rows']
        }
        return results
    
    def compare_clinical_data(self, test_df: pd.DataFrame, control_df: pd.DataFrame):
        """
        description:
        Compares a test dataframe of clinical data to a control dataframe to determine how accurate the test dataframe is.

        returns:
        A dictionary with results that describe the accuracy of the test CDF.

        params:
        test_cdf: The cdf we're testing for accuracy (ususally generated by HECTRE)
        control_cdf: The cdf we're comparing to the test cdf to determine accuracy. Considered to be 100% accurate.
        """
        # Create a DataFrame to hold comparison summary.
        comp_rows = pd.DataFrame(columns=['Exists in Test', 'Equals Test', 'Unique in Test', 'Unique in Control'], index=control_df.index, dtype='boolean')
        # Create a DataFrame to hold cell-by-cell equality matrix. Initialize every value to False.
        comp_values = pd.DataFrame(0, columns=test_df.columns, index=test_df.index, dtype='Int64')
        num_matched_rows = 0
        for i_control_df, row in control_df.iterrows():
            test_rows = test_df[test_df.index.isin([i_control_df])]
            control_rows = control_df[control_df.index.isin([i_control_df])]
            row_results = {
                'Exists in Test': False,
                'Unique in Test': False,
                'Unique in Control': False
            }
            if not test_rows.empty:
                num_matched_rows += 1
                matched_row = test_rows.iloc[0]
                matched_row_index = test_rows.index[0]
                row_results['Exists in Test'] = True
                if test_rows.shape[0] == 1:
                    row_results['Unique in Test'] = True
                for index_s, val_s in matched_row.items():
                    comp_values.loc[i_control_df, index_s] = fuzz.token_sort_ratio(val_s, row[index_s])
                # Drop already matched rows. Note: if there are multiple rows in the test cdf that match a given row in the control cdf
                # this comparison will always use the first match for the comparison. The rest will be dropped from the test cdf. A
                # possible optimization is to compare against the match with the highest accuracy if there's multiple matches in the test cdf.
                test_df.drop(index=matched_row_index, inplace=True)
            row_results['Unique in Control'] = (control_rows.shape[0] == 1)
            comp_rows.loc[i_control_df] = row_results
        results = {
            'comp_rows': comp_rows,
            'comp_values': comp_values,
            'num_matched_rows': num_matched_rows
        }
        return results
    
    def compare_literature_data(self, test_s: pd.Series, control_s: pd.Series):
        # Create a DataFrame to hold cell-by-cell equality matrix.
        comp_values = pd.Series(index=test_s.index, dtype='Int64')
        for index_s, val_s in test_s.items():
            comp_values.loc[index_s] = fuzz.token_sort_ratio(val_s, control_s[index_s])
        results = {
            'comp_values': comp_values
        }
        return results




